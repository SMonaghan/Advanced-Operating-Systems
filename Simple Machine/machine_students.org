* Machine:
** 3 register machine:  
   - %a, %b, %c
   - %ip, %sp
** Constants: 
   - start with $ -- For example, $0x500, and $37337
** Arrays:
   - %r[x]    -- references the value in the array pointed to by %r
                 (register in %a, %b, ...), and offsets into the array
                 by x (where x is a label, constant, or register).
                 Note that all structres can essentially be treated as arrays,
                 where each field in the struct is a specific offset in the array.
** Instructions:
   - mov x, y -- move x to b
   - push x   -- copy x onto the stack, and %sp -= 4 (stack grows down)
   - pop %r   -- copy value on the top of the stack to register %r (in
                 %a, %b, ...) and %sp += 4
   - label:   -- can be used to refer to the next instruction's
                 address
   - jmp l    -- set %ip to a location (address) l
   - sysenter -- switch %ip to syscall_handler label in kernel, does
                 not change other registers
   - sysexit  -- switch from kernel to user.  Set %ip/%sp to %a/%b
   - switchvas-- switch between virtual address spaces.  We can assume
                 there are only two, and that this switches between
                 them.  This instruction is really mov pgtbl, %cr3
   - %thd     -- this returns the address (label in memory, see below)
                  of the current thread control block
   - %otherthd-- this returns the address of the other thread's
                  control block
   - assume there are only 2 threads!
** Memory:
   - You can assume memory is laid out however you want, with labels
     on data as required
   - You can assume there are only two threads in the system (thus
     only two tcbs), and their structures memory is at the labels
     thd1: and thd2:.
* Assignment:
** Thread switch (user-level) code
** System call
** 1-1, cooperative thread switch
** Performance




















** System call


















** 1-1, cooperative thread switch (syscall then thread switch)
















** What is the performance, in cycles for each of these implementations?
*** This the following architecture cost model
**** Load and store instructions = 15 cycles (L2 hit)
**** sysenter  = 80  cycles
**** sysexit   = 70  cycles
**** switchvas = 150 cycles
**** all other instructions = 1 cycle
*** Thread switch





*** System call




*** 1-1 thread




* Sample solutions:
** thread switch code (wrong solution)
- This solution is incorrect.  Why?

# data
thd1:
sp
stack[STACKSIZE]

thd2:
sp
stack[STACKSIZE]

# code
switch_thd:
push %a
push %b
push %c
push %ip
mov  %sp, %thd
mov  %otherthd, %sp
pop  %ip
pop  %c
pop  %b
pop  %a
